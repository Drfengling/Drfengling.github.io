{"meta":{"title":"浅梦博客","subtitle":"","description":"","author":"浅梦风凌","url":"https://drfengling.github.io","root":"/"},"pages":[{"title":"First Page","date":"2022-04-15T01:07:09.000Z","updated":"2022-04-15T01:07:09.497Z","comments":true,"path":"First-Page/index.html","permalink":"https://drfengling.github.io/First-Page/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-13T07:51:45.000Z","updated":"2022-04-13T07:52:43.976Z","comments":true,"path":"categories/index.html","permalink":"https://drfengling.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-13T07:56:41.000Z","updated":"2022-04-13T07:57:08.135Z","comments":true,"path":"tags/index.html","permalink":"https://drfengling.github.io/tags/index.html","excerpt":"","text":""},{"title":"飙升榜","date":"2022-04-15T06:51:57.000Z","updated":"2022-04-16T05:36:33.150Z","comments":true,"path":"playlist/index.html","permalink":"https://drfengling.github.io/playlist/index.html","excerpt":"","text":"如果没有显示歌单,请刷新一下."}],"posts":[{"title":"Nginx配置详解及设置代理服务器","slug":"Nginx配置详解及设置代理服务器","date":"2022-05-12T07:45:38.000Z","updated":"2022-05-12T09:03:43.400Z","comments":true,"path":"qm/ec296788.html","link":"","permalink":"https://drfengling.github.io/qm/ec296788.html","excerpt":"nginx配置详解及设置代理服务器 nginx简单介绍Nginx是⼀款⾃由的、开源的、⾼性能的HTTP服务器和反向代理服务器；同时也是⼀个IMAP、POP3、SMTP代理服务器；Nginx可以作为⼀个HTTP服务器进⾏⽹站的发布处理，另外Nginx可以作为反向代理进⾏负载均衡的实现。通常我们主要使⽤nginx作为服务代理和负载均衡。本⽂主要介绍如何使⽤nginx作为服务代理的。","text":"nginx配置详解及设置代理服务器 nginx简单介绍Nginx是⼀款⾃由的、开源的、⾼性能的HTTP服务器和反向代理服务器；同时也是⼀个IMAP、POP3、SMTP代理服务器；Nginx可以作为⼀个HTTP服务器进⾏⽹站的发布处理，另外Nginx可以作为反向代理进⾏负载均衡的实现。通常我们主要使⽤nginx作为服务代理和负载均衡。本⽂主要介绍如何使⽤nginx作为服务代理的。 nginx安装https://nginx.org/版本介绍Mainline version 处于开发阶段的版本Stable version 属于比较稳定的版本,建议使用该版本Legacy versions 一些旧的版本下载后进行解压(Windows版本和Linux版本的目录结果都是一样的)conf 主要的配置文件nginx.exe 启动文件cmd命令行都可以启动nginx服务 nginx配置文件详解Nginx服务代理和负载均衡都可以通过修改conf/nginx.conf文件进行配置 1nginx.conf文件配置属性详解通过记事本或者其他软件打开时的内容如下所示(#号表示注释)为了方便阅读,我直接在代码旁对各个属性进行解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282#定义Nginx运⾏的⽤户和⽤户组user www www;#nginx进程数，建议设置为等于CPU总核⼼数。worker_processes 8;#全局错误⽇志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid⽂件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最⼤描述符：数⽬#⼯作模式与连接数上限#这个指令是指当⼀个nginx进程打开的最多⽂件描述符数⽬，理论值应该是最多打开⽂件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持⼀致。#现在在linux 2.6内核下开启⽂件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的⾼性能⽹络I/O模型，linux建议epoll，如果跑在FreeBSD上⾯，就⽤kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的⽅法，nginx会选择select或poll #B）⾼效事件模型 #Kqueue：使⽤于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使⽤双处理器的MacOS X系统使⽤kqueue可能会造成内核崩溃。 #Epoll：使⽤于Linux内核2.6版本及以后的系统。 #/dev/poll：使⽤于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使⽤于Solaris 10。为了防⽌出现内核崩溃的问题，有必要安装安全补丁。 use epoll; #单个进程最⼤连接数（最⼤连接数=连接数*进程数） #根据硬件调整，和前⾯⼯作进程配合起来⽤，尽量⼤，但是别把cpu跑到100%就⾏。每个进程允许的最多连接数，理论上每台nginx服务器的最⼤连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区⼤⼩。这个可以根据你的系统分页⼤⼩来设置，⼀般⼀个请求头的⼤⼩不会超过1k，不过由于⼀般系统分页都要⼤于1k，所以这⾥设置为分页⼤⼩。 #分页⼤⼩可以⽤命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页⼤⼩”的整倍数。 client_header_buffer_size 4k; #这个将为打开⽂件指定缓存，默认是没有启⽤的，max指定缓存数量，建议和打开⽂件数⼀致，inactive是指经过多长时间⽂件没被请求后删除缓存。open_file_cache max=65535 inactive=60s; #这个是指多长时间检查⼀次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使⽤字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项⽬的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内⽂件的最少使⽤次数，如果超过这个数字，⽂件描述符⼀直是在缓存中打开的，如上例，如果有⼀个⽂件在inactive时间内⼀次没被使⽤，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使⽤字段:http, server, location 这个指令指定了在open_file_cache指令⽆效的参数中⼀定的时间范围内可以使⽤的最⼩⽂件数,如果使⽤更⼤的值,⽂件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使⽤字段:http, server, location 这个指令指定是否在搜索⼀个⽂件是记录cache错误. open_file_cache_errors on;&#125;#设定http服务器，利⽤它的反向代理功能提供负载均衡⽀持http&#123; #⽂件扩展名与⽂件类型映射表 include mime.types; #默认⽂件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表⼤⼩ #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的⼤⼩，并且是⼀路处理器缓存⼤⼩的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于⼀路处理器缓存的⼤⼩，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第⼀次是确定存储单元的地址，第⼆次是在存储单元中查找键值。因此，如果Nginx给出需要增⼤hash max size 或 hash bucket size的提⽰，那么⾸要的是增⼤前⼀个参数的⼤⼩. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区⼤⼩。这个可以根据你的系统分页⼤⼩来设置，⼀般⼀个请求的头部⼤⼩不会超过1k，不过由于⼀般系统分页都要⼤于1k，所以这⾥设置为分页⼤⼩。分页⼤⼩可以⽤命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲⼤⼩。nginx默认会⽤client_header_buffer_size这个buffer来读取header值，如果header过⼤，它会使⽤large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传⽂件的⼤⼩ client_max_body_size 8m; #开启⾼效⽂件传输模式，sendfile指令指定nginx是否调⽤sendfile函数来输出⽂件，对于普通应⽤设为 on，如果⽤来进⾏下载等应⽤磁盘IO重负载应⽤，可设置为off，以平衡磁盘与⽹络I/O处理速度，降低系统的负载。注意：如果图⽚显⽰不正常把这个改成off。 #sendfile指令指定 nginx 是否调⽤sendfile 函数（zero copy ⽅式）来输出⽂件，对于普通应⽤，必须设为on。如果⽤来进⾏下载等应⽤磁盘IO重负载应⽤，可设置为off，以平衡磁盘与⽹络IO处理速度，降低系统uptime。 sendfile on; #开启⽬录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁⽌使⽤socke的TCP_CORK的选项，此选项仅在使⽤sendfile的时候使⽤ tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善⽹站的性能：减少资源占⽤，提⾼访问速度。下⾯参数看字⾯意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最⼩压缩⽂件⼤⼩gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使⽤1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下⾯就不⽤再写了，写上去也不会有问题，但是会有⼀个warn。 gzip_vary on; #开启限制IP连接数的时候需要使⽤ #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表⽰权值，权值越⾼被分配到的⼏率越⼤。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream⽬前⽀持4种⽅式的分配 #1、轮询（默认） #每个请求按时间顺序逐⼀分配到不同的后端服务器，如果后端服务器down掉，能⾃动剔除。 #2、weight #指定轮询⼏率，weight和访问⽐率成正⽐，⽤于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问⼀个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三⽅） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三⽅） #按访问url的hash结果来分配请求，使每个url定向到同⼀个后端服务器，后端服务器为缓存时⽐较有效。 #例：在upstream中加⼊hash语句，server语句中不能写⼊weight等其他的参数，hash_method是使⽤的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使⽤负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表⽰单前的server暂时不参与负载 #2.weight为weight越⼤，负载的权重就越⼤。 #3.max_fails：允许请求失败的次数默认为1.当超过最⼤次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup：其它所有的⾮backup机器down或者忙的时候，请求backup机器。所以这台机器压⼒会最轻。nginx⽀持同时设置多组的负载均衡，⽤来给不⽤的server来使⽤。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到⽂件中⽤来做debug #client_body_temp_path设置记录⽂件的⽬录可以设置最多3层⽬录 #location对URL进⾏匹配.可以进⾏重定向或者进⾏新的代理负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端⼝ listen 80; #域名可以有多个，⽤空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进⾏负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图⽚缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #⽇志格式设定 #$remote_addr与$http_x_forwarded_for⽤以记录客户端的ip地址； #$remote_user：⽤来记录客户端⽤户名称； #$time_local：⽤来记录访问时间与时区； #$request：⽤来记录请求的url与http协议； #$status：⽤来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端⽂件主体内容⼤⼩； #$http_referer：⽤来记录从那个页⾯链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后⾯，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，⽤以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;; #定义本虚拟主机的访问⽇志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启⽤反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取⽤户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是⼀些反向代理的配置，可选。proxy_set_header Host $host; #允许客户端请求的最⼤单⽂件字节数 client_max_body_size 10m; #缓冲区代理缓冲⽤户端请求的最⼤字节数， #如果把它设置为⽐较⼤的数值，例如256k，那么，⽆论使⽤firefox还是IE浏览器，来提交任意⼩于256k的图⽚，都很正常。如果注释该指令，使⽤默认的client_body_buffer_size设置，也就是操作系统页⾯⼤⼩的两倍，8k或者16k，问题就出现了。 #⽆论使⽤firefox4.0还是IE8.0，提交⼀个⽐较⼤，200k左右的图⽚，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表⽰使nginx阻⽌HTTP应答代码为400或者更⾼的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握⼿等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进⼊后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存⽤户头信息的缓冲区⼤⼩ #设置从被代理服务器读取的第⼀部分应答的缓冲区⼤⼩，通常情况下这部分应答中包含⼀个⼩的应答头，默认情况下这个值的⼤⼩为指令proxy_buffers中指定的⼀个缓冲区的⼤⼩，不过可以将其设置为更⼩ proxy_buffer_size 4k; #proxy_buffers缓冲区，⽹页平均在32k以下的设置 #设置⽤于读取应答（来⾃被代理服务器）的缓冲区数⽬和⼤⼩，默认情况也为分页⼤⼩，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #⾼负荷下缓冲⼤⼩（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写⼊proxy_temp_path时数据的⼤⼩，预防⼀个⼯作进程在传递⽂件时阻塞太长 #设定缓存⽂件夹⼤⼩，⼤于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd⽂件的内容可以⽤apache提供的htpasswd⼯具来产⽣。 &#125; #本地动静分离反向代理配置 #所有jsp的页⾯均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态⽂件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d;&#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125; 上⾯的⼀些配置详解仅供参考学习 2 配置服务代理：第⼀步：打开nginx.conf⽂件，修改配置⽂件为了⽅便阅读，我把⼀些不⽤的配置给删除了1234567891011121314151617181920212223242526272829worker_processes 1;events &#123; worker_connections 1024;&#125;#http结构下可以有多个server。请求进来确定使⽤哪⼀个 server由 server_name 确定http &#123; include mime.types; default_type application/octet-stream; sendfile on; server &#123; #第⼀个server listen 81;#nginx的监听端⼝为81 server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 8001; server_name localhost; location ~ /PMS/ &#123; proxy_pass http://localhost:8080; &#125; &#125;&#125; 配置过程的注意事项： 1 nginx启动等命令 配置好后，需要重新启动nginx（来到nginx.exe⽂件下打开cmd界⾯）：关闭的命令：nginx.exe - s stop 启动命令：nginx.exe 重新加载配置命令：nginx.exe - s reload 2 location 详解 2.1 location介绍location :⼀个server下可以有多个location ，⽤来匹配 同⼀个域名下不同uri的访问root 表⽰本地的根⽬录 ,可以写相对路径 也可以写绝对路径如 e：/nginx/html ；index :访问主页 后⾯如果跟有多个页⾯ 则会依次判断 如果第⼀个不存在 则向后匹配；proxy_pass ：转发 后跟系统地址 2.2 location匹配原则location表达式syntax: location [=|~ | * |^|@] /uri/ { - }分为两种匹配模式，普通字符串匹配，正则匹配⽆开头引量字符或以=开头表⽰普通字符电匹配以~ 或 ~ * 开头表⽰正则匹配，~ * 表⽰不区分⼤⼩写多个locati on时匹配规则总体是先普通后正则原则，只识别URI部分，例如请求为/test/1/abc . do?arg=xxx 先查找是否有=开头的精确匹配。即Location = /test/1/abc.do {…} 再查找普通匹配，以最⼤前缀为规则，如有以下两个locationlocation /test/ {…}location /test/1/ {…}则匹配后⼀项 匹配到⼀个普通格式后，搜索并未结束。⽽是暂存当前结果，并继续再搜索正则模式 在所有正则模式lacation中找到第⼀个匹配项后，以此四配项为最终结果所以正则匹配项匹配规则受定义前后顺序影响。但普通匹配不会 如果未找到正则匹配项，则以3中缓存的结果为最终结果 如果⼀个匹配都没有，返回404location =/ {…} 与location / {…} 的差别前⼀个是精确匹配，只响应/请求，所有/xxx类请求不会以前缀匹配形式匹配到它⽽后⼀个正相反，所有请求必然都是以/开头，所以没有其它匹配结果时⼀⼆定会执⾏到它location A- 1 {…} A-意思是⾲正则。表⽰匹配到此模式后不再继线正则搜索#所有如果这样配置，相当于关团了正则匹配功能#因为⼀个请求在普通匹配规则下没得到其它普通匹配结果时，最終匹配到这⾥⽽这个^-指令⼜相当于不允许正则，.机当于匹配到此为⽌/test/abc.jsp **特别强调⼀点在配置 proxy_pass 记得在url不要加上斜杠/","categories":[{"name":"Web服务","slug":"Web服务","permalink":"https://drfengling.github.io/categories/Web%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://drfengling.github.io/tags/Nginx/"}]},{"title":"C#WCF方向(三)","slug":"C-WCF方向-三","date":"2022-05-06T06:27:39.000Z","updated":"2022-05-12T09:04:07.144Z","comments":true,"path":"qm/31480aad.html","link":"","permalink":"https://drfengling.github.io/qm/31480aad.html","excerpt":"主题 序列化机制 数据契约 消息契约 Demo","text":"主题 序列化机制 数据契约 消息契约 Demo 序列化 SerializationA格式 转换 B格式Transformer序列化器 1.BinaryFormatter 二进制平台2.SoapFormatter SOAP3.XmlSerializer Xml强大的控制 类型有限4.DataContractSerializer WCF优化5.NetDataContractSerializer WCF二进制6.DataContractJsonSerializer JSON WCF序列化过程参数对象 序列化 传输 反序列化 执行操作 返回结果 序列化 传输 数据契约消息契约 允许完全控制消息体 SOAP消息头 Header SOAP消息体 Body消息契约示例12345678910public class MyMessage&#123; [MessageHeader] public string Operation; [MessageHeader] public string Name; [MessageBodyMember] public int Age; [MessageBodyMember] public string Home;&#125; WCF序列化器 支持的数据类型 无参构造函数的Pulbic类 数据契约类 集合类:Ienumerable,IDictionary,CollectionDataContract 枚举类 .NET基元类: Byte,Sbyte,Int16,Int32等 SerializableAttribute 属性标记的类型 原始XML类型和ADO.NET关系数据的类型 WCF使用XmlSerializer1234567[ServiceContract][XmlSerializerFormat]public interface MyService&#123; [OperationContract] [XmlSerializerFormat] void MyMethod();&#125; C#使用XmlSerializer12345XmlSerializer serializer=new XmlSerializer(typeof(Order));TextWriter writer=new StreamWriter(filename);Order order=new Order();serializer.Serialize(writer,po);writer.Close(); C#中使用DataContractSerializer1234FileStream writer=new FileStream(filename,FileMode.Create);DataContractSerializer ser=new DataContractSerializer(typeof(Person));ser.WriteObject(writer,pl);writer.Close();","categories":[{"name":"C#","slug":"C","permalink":"https://drfengling.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengling.github.io/tags/WCF/"}]},{"title":"C#WCF方向(二)","slug":"C-WCF方向-二","date":"2022-05-04T01:24:05.000Z","updated":"2022-05-06T02:08:58.851Z","comments":true,"path":"qm/4fbb2a86.html","link":"","permalink":"https://drfengling.github.io/qm/4fbb2a86.html","excerpt":"主题1.终结点 Endpoint2.契约 Contract3.宿主 Host4.绑定 Binding5.Demo:定义契约,终结点,配置绑定","text":"主题1.终结点 Endpoint2.契约 Contract3.宿主 Host4.绑定 Binding5.Demo:定义契约,终结点,配置绑定 必备知识1.了解.Net Framework2.了解Asp.net应用程序开发3.熟悉Visual Studio 可选知识1.Enterprise Services(COM+)2..Net Remoting3.Asp.Net web Service(ASMX) 终结点 EndPoint1.2种类型 终结点 元数据终结点 普通终结点 地址 Address 相对地址 绝对地址 基地址 BaseAddress 基础地址 (下面http://localhost:6054就是基地址)123&lt;endpoint address=&quot;http://localhost:6054/ServiceDemo.svc&quot; binding=&quot;basicHttpBinding&quot; bindingConfiguration=&quot;BasicHttpBinding_IServiceDemo&quot; contract=&quot;ServiceReferenceDemo.IServiceDemo&quot; name=&quot;BasicHttpBinding_IServiceDemo&quot;/&gt; 绑定 Binding 绑定是特殊配置元素(称作“绑定元素”)的集合,服务运行库在每次构造客户端或服务终结点时都对这些元素进行评估 WCF里的传输协议,安全,事务,消息编码,超时等等都是由绑定来控制 控制WCF的一个接口绑定列表 Windows Azure AppFabric绑定 NetTcpRelayBinding 消息中途转发机制 NetOneWayRelayBinding 消息单向转发 NetEventRelayBinding 基于事件的 webHttpRelayBinding WS2007HttpRelayBinding WCF绑定和通道堆栈 绑定的结构 绑定结构例子 契约 Contract契约是通信参与方之间的约定 数据契约 DataContract 实体类 操作契约 Operation Contract 服务方法 服务契约 Service Contract 服务 消息契约 Message Contract 对消息体的完整控制 错误契约 Fault Contract 把错误信息包装起来返回给客户端 数据契约12345678910[DataContract]//数据契约属性声明 public class UserData &#123; [DataMember]//数据成员标记 public string Name&#123;set;get;&#125;; [DataMember(Name=&quot;UserEmail&quot;)]//支持别名定义 public string Email&#123;set;get;&#125;; &#125; 序列化1.XmlSerialzer2.DataContractSerializer3.NetDataContractSerializer NetTcp使用的4.DataContractJsonSerializer json数据序列化 服务契约ServiceContract定义约定的服务 1234567891011[ServiceContract]//服务契约 public interface IServiceDemo &#123; [OperationContract]//操作契约 string GetData(int value); [OperationContract] UserData GetDataUsingDataContract(UserData user); // TODO: Add your service operations here &#125; 操作契约12[OperationContract]//操作契约 string GetData(int value); 消息契约 MessageContract1.允许完全控制消息体2.SOAP消息头 header3.SOAP 消息体 Body 错误契约 FaultContract1.为了在客户端和服务端共享错误信息2.错误处理 宿主HostIIS.EXE.WinForm.Wpf.WindowService.NT Service.COM+ 托管进程 怎么托管WCF服务 Window Server AppFabric WCF绑定学习资源 书籍 Inside WCF,(Justin Smith) 《WCF技术内幕》 第8章 绑定 文章 Aaron Skonnard 深入学习WCF绑定 WCF服务配置管理工具点击Visual Studio导航栏 工具 WCF配置编辑器打开配置文件app.config Demo 定义契约 配置终结点 使用绑定定义契约 1.打开Visual Studio,创建新项目,我们搜索wcf,选择wcf服务库,2.自定义项目名称路径创建即可(后面不再图文赘述)3.这里做简单更改 IService1123456789101112131415161718192021222324// 注意: 使用“重构”菜单上的“重命名”命令，可以同时更改代码和配置文件中的接口名“IService1”。 [ServiceContract] public interface IService1 &#123; [OperationContract] string SayHello(string Name); [OperationContract] string SayHellotoUser(User user); &#125; // 使用下面示例中说明的数据约定将复合类型添加到服务操作。 // 可以将 XSD 文件添加到项目中。在生成项目后，可以通过命名空间“WcfService.ContractType”直接使用其中定义的数据类型。 [DataContract] public class User &#123; [DataMember] public string FirstName &#123; get; set; &#125; [DataMember] public string SecondName &#123; set; get; &#125; &#125; Service112345678910111213141516public class Service1 : IService1 &#123; public string SayHello(string Name) &#123; string result = $&quot;Hello,&#123;Name&#125;&quot;; Console.WriteLine(result); return result; &#125; public string SayHellotoUser(User user) &#123; string result = $&quot;Hello,&#123;user.FirstName&#125;&#123;user.SecondName&#125;&quot;; Console.WriteLine(result); return result; &#125; &#125; 配置终结点 1.右键解决方案添加2.新建项目 搜索控制台 选择控制台应用程序创建WcfHost3.添加对定义契约的Wcf服务类库的引用,我们打开Program.cs文件创建打开服务. 123456using (ServiceHost host=new ServiceHost(typeof(WcfService.Service1))) &#123; host.Open(); Console.WriteLine($&quot;Host is Running,and State is &#123;host.State&#125;&quot;); Console.ReadLine(); &#125; 4.打开app.config 配置终结点 这里配置了4个终结点 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;system.web&gt; &lt;compilation debug=&quot;true&quot; /&gt; &lt;/system.web&gt; &lt;!-- 部署服务库项目时，必须将配置文件的内容添加到 主机的 app.config 文件中。System.Configuration 不支持库的配置文件。 --&gt; &lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=&quot;WcfService.Service1&quot;&gt; &lt;host&gt; &lt;baseAddresses&gt; &lt;add baseAddress=&quot;http://localhost:8001&quot;/&gt; &lt;add baseAddress=&quot;net.tcp://localhost:8002&quot;/&gt; &lt;!--&lt;add baseAddress = &quot;http://localhost:8733/Design_Time_Addresses/WcfService/Service1/&quot; /&gt;--&gt; &lt;/baseAddresses&gt; &lt;/host&gt; &lt;!-- Service Endpoints --&gt; &lt;!-- 除非完全限定，否则地址相对于上面提供的基址--&gt; &lt;endpoint address=&quot;http://localhost:8001/WcfService&quot; binding=&quot;wsHttpBinding&quot; name=&quot;httpEndpoint&quot; contract=&quot;WcfService.IService1&quot;&gt; &lt;/endpoint&gt; &lt;endpoint address=&quot;net.tcp://localhost:8002/WcfService&quot; binding=&quot;netTcpBinding&quot; name=&quot;tcpEndpoint&quot; contract=&quot;WcfService.IService1&quot;&gt; &lt;/endpoint&gt; &lt;!-- Metadata Endpoints --&gt; &lt;!-- 元数据交换终结点供相应的服务用于向客户端做自我介绍。 --&gt; &lt;!-- 此终结点不使用安全绑定，应在部署前确保其安全或将其删除--&gt; &lt;endpoint address=&quot;mex&quot; binding=&quot;mexHttpBinding&quot; contract=&quot;IMetadataExchange&quot; name=&quot;httpMex&quot;/&gt; &lt;endpoint address=&quot;mex&quot; binding=&quot;mexTcpBinding&quot; contract=&quot;IMetadataExchange&quot; name=&quot;tcpMex&quot;/&gt; &lt;/service&gt; &lt;/services&gt; &lt;behaviors&gt; &lt;serviceBehaviors&gt; &lt;behavior&gt; &lt;!-- 为避免泄漏元数据信息， 请在部署前将以下值设置为 false --&gt; &lt;serviceMetadata httpGetEnabled=&quot;True&quot; httpsGetEnabled=&quot;True&quot;/&gt; &lt;!-- 要接收故障异常详细信息以进行调试， 请将以下值设置为 true。在部署前设置为 false 以避免泄漏异常信息 --&gt; &lt;serviceDebug includeExceptionDetailInFaults=&quot;False&quot; /&gt; &lt;/behavior&gt; &lt;/serviceBehaviors&gt; &lt;/behaviors&gt; &lt;/system.serviceModel&gt; 5.点击导航栏生成重新生成解决方案,设置WcfHost为启动项目启动项目6.我们关闭Visual Studio,找到Visual Studio右键以管理员权限运行,重新打开项目并启动.完成!基于控制台的Wcf服务搭建完成,我们新建一个客户端来测试服务. 使用绑定1.右键解决方案,添加 新建项目 新建控制台应用程序WcfClient2.点击引用, 点击发现或手动输入添加服务引用3.打开Program.cs测试服务 1234567Service1Client client1 = new Service1Client(&quot;httpEndpoint&quot;); Console.WriteLine(client1.SayHello(&quot;浅梦风凌&quot;)); User user1 = new User(); user1.FirstName = &quot;浅梦&quot;; user1.SecondName = &quot;风凌&quot;; Console.WriteLine(client1.SayHellotoUser(user1)); Console.Read(); 4.导航栏生成重新生成解决方案,启动1.启动前右键解决方案,点击属性,配置多个启动项目2.启动好了,可以看到服务调用结果了.完成!我们的Wcf从创建服务到配置绑定到测试已经全部完成了。 对tcp终结点的调用如下123456Service1Client client2 = new Service1Client(&quot;tcpEndpoint&quot;); Console.WriteLine(client2.SayHello(&quot;小猫&quot;)); User user2 = new User(); user2.FirstName = &quot;海边的&quot;; user2.SecondName = &quot;海边&quot;; Console.WriteLine(client1.SayHellotoUser(user2));","categories":[{"name":"C#","slug":"C","permalink":"https://drfengling.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengling.github.io/tags/WCF/"}]},{"title":"C#WCF方向(一)","slug":"C-WCF方向-一","date":"2022-05-03T05:55:35.000Z","updated":"2022-05-04T01:40:47.529Z","comments":true,"path":"qm/e08ab1e4.html","link":"","permalink":"https://drfengling.github.io/qm/e08ab1e4.html","excerpt":"WCF开始入手WCF了,从零开始,记录一下WCF的学习笔记 什么是WCF摘要WCF是使用托管代码建立和运行面向服务（Service Oriented）应用程序的统一框架。它使得开发者能够建立一个跨平台的安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。","text":"WCF开始入手WCF了,从零开始,记录一下WCF的学习笔记 什么是WCF摘要WCF是使用托管代码建立和运行面向服务（Service Oriented）应用程序的统一框架。它使得开发者能够建立一个跨平台的安全、可信赖、事务性的解决方案，且能与已有系统兼容协作。WCF是微软分布式应用程序开发的集大成者，它整合了.Net平台下所有的和分布式系统有关的技术，例如.Net Remoting、ASMX、WSE和MSMQ。以通信(Communiation)范围而论，它可以跨进程、跨机器、跨子网、企业网乃至于 Internet；以宿主程序而论，可以以ASP.NET，EXE，WPF，Windows Forms，NT Service，COM+作为宿主(Host)。 简述1.WCF全称Windows Communication Foundation2.是Miscrosoft为构建面向服务的应用提供的分布式通信编程框架3.是.Net Framework的重要组成部分.4.WCF4.0历史ASMX WSE WCF3.0 WCF3.5 WCF4.0 WCFN.0 集成微软分布式技术WCF:WSE. MSMQ. Enterprise Service COM+ .NET Remoting ASP.NET Web Service 托管方式多样化托管(Host)IIS EXE Winform wpf Window Service NT Service COM+ 统一编程模型Client Talk to (Binding,Address,Contract)1.Address: 每一个WCF的Service都有一个唯一的地址。这个地址给出了Service的地址和传输协议(Transport Protocol)。2.Binding:绑定制定了服务通过什么形式访问。只要类比传输协议, encoding (text, binary, etc) 以及 WS-* 协议，像transactional支持以及可信任的消息队列。3.Contract:Contract描述了Service能提供的各种服务。Contract有四种，包括Service Contract, Data Contract, Fault Contract和Message Contract。 WCF知识点1.契约 Contract2.宿主 Host3.绑定 Binding4.事务 Transaction5.消息队列 MSMQ6.并发控制 Concurrency Control7.错误处理 Error Handling8.安全 Security9.诊断与调试 软件工程的发展历史面向过程PO 面向对象OO 面向组件CO 面向服务SO SOA的特征1.Service Oriented Architecture2.面向服务的架构互操作 重用 松耦合 Web服务类别SOAP RESTsoap:简单对象访问协议rest：轻量级WebApi服务 Web服务使用的领域开发中间产品 暴露接口服务 集成第三方系统 应用系统中的Web服务表现层服务层业务逻辑层——&gt; ESB企业服务总线 ——&gt;服务数据访问层数据 数据 系统集成中的Web服务 电子商务网站订单系统 | | |银行服务 库存系统服务 短信服务 Demo1.创建一个WCF服务程序 程序并调用打开Visual Studio开发工具 我这里用的2022左上角菜单 文件 点击新建 选择项目 打开了创建新项目的对话框 我们在搜索栏搜素wcf搜索结果如下所示:这里选择WCF服务应用程序自定义下项目名 位置 这里选用.Net4.5.2框架 创建即可创建完成后 默认会添加IService1.cs,Service1.svc文件,.svc扩展文件,它会做一些消息的路由工作,激活服务,会通过文件做一些处理.IService1.csServiceContract:服务契约包含两个操作契约OperationContract：GetData,GetDataUsingDataContract 使用数据契约获取数据DataContract:数据契约:包含两个值 bool StringValue做下自定义更改1.增加数据契约对象我们在IService1.cs中创建一个类自定义命名我的如下新增一个用户数据对象,增加以下内容 1234567[DataContract]//数据契约对象 public class UserData &#123; [DataMember] public string UserName &#123; get; set; &#125; [DataMember] public string Email &#123; get; set; &#125; &#125; 2.增加服务契约接口我们在IService1.cs中interface IService1中新增接口 12345678// TODO: 在此添加您的服务操作 /// &lt;summary&gt; /// 自定义服务契约 /// &lt;/summary&gt; /// &lt;param name=&quot;user&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [OperationContract]///注意:增加操作契约标记 UserData GetUserData(UserData user); 3.在Service1.svc中新增实现 1234///新增实现 public UserData GetUserData(UserData user) &#123; return user; &#125; 到此，我们已完成了简单的数据服务实现契约,点击导航栏生成——&gt;重新生成解决方案,确认无报错后执行下一步4.在浏览器中查看点击Service1.svc右键选择在浏览器中查看visual Studio打开浏览器,跳转服务界面.出现这个界面,说明你的服务是正常的.可以发布了.我们看到 1svcutil.exe http://localhost:60217/Service1.svc?wsdl wsdl:服务描述语言,对外公布的服务语言,你想让别人引用你的服务的话,就可以引用这个.我们可以看到下方有客户端调用示例.后面客户端调用服务可以仿照使用 1234567891011121314151617181920212223242526C#class Test&#123; static void Main() &#123; Service1Client client = new Service1Client(); // 使用 &quot;client&quot; 变量在服务上调用操作。 // 始终关闭客户端。 client.Close(); &#125;&#125;Visual BasicClass Test Shared Sub Main() Dim client As Service1Client = New Service1Client() &#x27; 使用 &quot;client&quot; 变量在服务上调用操作。 &#x27; 始终关闭客户端。 client.Close() End SubEnd Class 5.新增WPF项目我们在解决方案下新增一个WPF项目(也可以新增一个网站项目,Winform项目等)自定义名字WCFClient创建.6.引用服务在创建好的wpf项目中选择引用,右键选择添加服务引用,打开如下:我们输入步骤4在浏览器打开后生成的公共服务语言 1http://localhost:60217/Service1.svc?wsdl 自定义命名空间名称ServiceReference确定.提示:我们也可以点击发现.发现解决方案中的服务.服务栏会为我们找到对应服务.点击Service1.svc打开到IService1,即可查看右侧列表显示的三个服务接口,两个默认的服务接口契约,和一个我们新增的GetUserData服务契约.(如果没有显示新增的接口,请返回WCF项目检查是否遗漏契约标记)点击添加后的服务引用可以查看7.使用Wpf调用服务 打开MainWindow新增Button按钮,可以打开工具栏拖动Button到界面上,或编写Xaml文本增加,完成后调整布局.123456&lt;Grid HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;Button Width=&quot;100&quot; Height=&quot;30&quot; Content=&quot;调用服务&quot; Click=&quot;Button_Click&quot;/&gt; &lt;/Grid&gt; 点击Click事件F12进入后置代码,这里不做复杂框架处理,后置编写点击实现Wcf服务调用具体实现如下:123456789101112/// &lt;summary&gt; /// 调用WCF服务. /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void Button_Click(object sender, RoutedEventArgs e) &#123; Service1Client client = new Service1Client(); string result1 = client.GetData(1); UserData userData = client.GetUserData(new UserData() &#123; Email=&quot;Drfengling@163.com&quot;,UserName=&quot;浅梦风凌&quot;&#125;); client.Close(); &#125; 8.生成调试服务 点击导航栏生成 重新生成解决方案 确认无误后在点击事件处打断点调试 选择WCFClient为启动项目,点击导航栏调试开始调试,点击按钮调用服务,观察服务调用结果可以看到我们在客户端完成了对服务端的调用,调用获取到了WCF服务结果.快来动手试试搭建简单的服务调用吧. WCF的新特性WCF4.5新特性1.支持契约优先(Contract First)的开发2.Building发现配置错误3.支持新异步流4.?singleWSDL5.Websockets支持在端口80和4436.XML编辑器工具展示7.ChannelFactory缓存支持8.二进制编码器压缩支持9.不管Fire and foget的UDP消息发交换模式10.支持单个WCF终结点支持多个身份验证模式11.支持WCF服务使用国际化域名（IDNs） WCF学习资源1.最权威WCF书籍 Programing WCF Service,(Juval Lowy) 《WCF服务编程》第三版 Inside WCF,(Justin Smith) 《WCF技术内幕》 2.论坛 微软WCF中文技术论坛http://social.msdn.microsoft.com/Forums/zh-CN/wcfzhchs/threads 微软WCF英文技术论坛 跟我一起从零开始学WCF系列课程(由于官网视频已经失效了,有兴趣可以看看这篇博客)https://www.cnblogs.com/dqj1024/archive/2012/07/21/2602342.html","categories":[{"name":"C#","slug":"C","permalink":"https://drfengling.github.io/categories/C/"}],"tags":[{"name":"WCF","slug":"WCF","permalink":"https://drfengling.github.io/tags/WCF/"}]},{"title":"Hexo博客添加Gitalk评论","slug":"Hexo博客添加Gitalk评论","date":"2022-04-27T03:09:16.000Z","updated":"2022-04-27T06:30:08.568Z","comments":true,"path":"qm/212a5789.html","link":"","permalink":"https://drfengling.github.io/qm/212a5789.html","excerpt":"Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。更详细用法看官网https://github.com/gitalk/gitalk/blob/master/readme-cn.md这里只记录有诱惑的操作","text":"Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。更详细用法看官网https://github.com/gitalk/gitalk/blob/master/readme-cn.md这里只记录有诱惑的操作 1.申请秘钥申请一个 OAuth application https://github.com/settings/applications/new获取 ID 和 secrets，必须要保存好，然后以后就看不到了，忘记了只能重建。上面的填写成功之后进入,我们需要的是生成的Client ID 和Client Secret 2.存储仓库您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论如上所示,我新建了一个dryunment用来存储线上评论.如果没有可以点New新建一个仓库 3.博客配置上面的确认无误后，我们进行配置博客，引入gitalk。 首先进入主题的配置文件_config.yml(注意是主题的配置文件，不是博客根目录下的配置文件)，添加gitalk配置(一定要仔细，缺一不可)。 123456gitalk: owner: github用户名 admin: github用户名 repo: 博客的仓库名称(注意不是地址) ClientID: 上面生成的Client ID ClientSecret: 上面生成的Client Secret 上面配置完之后,进入主题目录\\themes\\kratos-rebirth\\layout_comments目录，在当前目录下新建一个gitalk.ejs文件，写入如下代码 1234567891011121314151617181920212223&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_npm_cdn(&#x27;gitalk@1/dist/gitalk.css&#x27;) %&gt;&quot;&gt;&lt;div id=&quot;gitalk-container&quot; class=&quot;post-comments lazy-load&lt;% if (theme.posts.comments?.enableBGImage) &#123; %&gt; bg-image&lt;% &#125; %&gt;&quot; style=&quot;padding-left:2rem; padding-right:2rem;&quot;&gt;&lt;/div&gt;&lt;script&gt; var load_comm = () =&gt; &#123; const init = () =&gt; &#123; console.log(&#x27;Gitalk loading...&#x27;); const gitalk = new Gitalk(Object.assign(&#123; id: &#x27;&lt;%- url_for(page.path) %&gt;&#x27;, path: &#x27;&lt;%- url_for(page.path) %&gt;&#x27; &#125;, JSON.parse(&#x27;&lt;%- JSON.stringify(theme.gitalk) %&gt;&#x27;))); gitalk.render(&#x27;gitalk-container&#x27;); &#125; if (typeof Gitalk === &#x27;undefined&#x27;) &#123; const src = &#x27;&lt;%- url_npm_cdn(&quot;gitalk@1/dist/gitalk.min.js&quot;) %&gt;&#x27;; $.getScript(src, init); &#125; else &#123; init(); &#125; &#125;;load_comm();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://github.com/gitalk/gitalk&quot;&gt;comments powered by Gitalk.&lt;/a&gt;&lt;/noscript&gt; 4.博客部署键入命令: 123hexo clhexo ghexo s 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上https://drfengling.github.io由于研究了多种博客评论系统 所以你看到的评论系统不一定是Gitalk.有问题评论区欢迎评论交流.到此,Gitalk评论系统就完成啦，快来动手试试吧.","categories":[{"name":"线上评论","slug":"线上评论","permalink":"https://drfengling.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"Gitalk","slug":"Gitalk","permalink":"https://drfengling.github.io/tags/Gitalk/"}]},{"title":"livere评论系统","slug":"livere评论系统","date":"2022-04-27T01:21:11.000Z","updated":"2022-04-27T02:54:19.927Z","comments":true,"path":"qm/d318877c.html","link":"","permalink":"https://drfengling.github.io/qm/d318877c.html","excerpt":"Hexo博客添加LiveRe评论系统好久不见,又是长长的探索实践之旅了,最近在新加评论系统出现了各种问题,也有所得.评论系统可以说五花八门啦，用得多的比如：Gitment、Gitalk、LiveRe、Disqus、disqusjs，twikoo, waline、Valine 等","text":"Hexo博客添加LiveRe评论系统好久不见,又是长长的探索实践之旅了,最近在新加评论系统出现了各种问题,也有所得.评论系统可以说五花八门啦，用得多的比如：Gitment、Gitalk、LiveRe、Disqus、disqusjs，twikoo, waline、Valine 等 这里以LiveRe为例:1.进入来必力官网 https://www.livere.com/2.右上角个人头像点进去 有账号可以直接登录3.没有就注册一个https://was.livere.me/register?lang=zh-cn,填写自己的邮箱,我这里用了网易163邮箱,可以根据自己情况填写,填写密码完成注册.4.注册以后登录进去，点击导航栏安装,选择City版进行安装，City版是免费的，对我们这种个人博客而言完全足够了5.接下来需要填写一些关于你想将LiveRe用于的博客的一些信息6.填完之后，申请获取代码，此时其将会给你一段代码，该段代码等下需要加到你的个人博客的页面中，我们可以先将其复制并保存起来。 LiveRe评论配置集成1.回到我们的博客根目录打开themes主题文件夹 我用的是kratos-rebirth主题,以kratos-rebirth为例:打开_config.yml文件更改配置我们更改Post Page 文章页配置posts下属性comments的属性取值这里用到的评论系统是livere 对应更改provider: livereenableBGImage用来配置背景图片2.找到\\kratos-rebirth\\layout_comments文件夹 更改 livere.ejs文件配置 没有可以创建一个3.打开livere文件,新增来必力评论代码如下: 1234567891011121314151617&lt;div id=&quot;lv-container&quot; class=&quot;post-comments lazy-load &lt;% if (theme.posts.comments?.enableBGImage) &#123; %&gt; bg-image&lt;% &#125; %&gt;&quot; data-id=&quot;&lt;%- theme.livere.id || &#x27;city&#x27; %&gt;&quot; data-uid=&quot;&lt;%- theme.livere.uid %&gt;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#x27;function&#x27;) &#123; return; &#125; j = d.createElement(s); j.src = &#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &#x27;script&#x27;);&lt;/script&gt;&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt; 老样子,先来三杯小鸟伏特加 powershell或命令行打开博客根目录键入命令: 123hexo clhexo ghexo s 本地部署完成后可以打开博客文章访问就可以看到文章下方加载除评论区了,选择账号登录就可以进行评论了.确认无误hexo d部署到服务器上https://drfengling.github.io由于研究了多种博客评论系统 所以你看到的评论系统不一定是livere.有问题评论区欢迎评论交流.到此,livere评论系统就完成啦，快来动手试试吧.","categories":[{"name":"线上评论","slug":"线上评论","permalink":"https://drfengling.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"}],"tags":[{"name":"livere","slug":"livere","permalink":"https://drfengling.github.io/tags/livere/"}]},{"title":"博客美化(一)","slug":"博客美化-一","date":"2022-04-16T06:03:16.000Z","updated":"2022-04-30T07:39:08.230Z","comments":true,"path":"qm/5f88ef60.html","link":"","permalink":"https://drfengling.github.io/qm/5f88ef60.html","excerpt":"博客美化1.添加鼠标点击爱心效果在\\themes\\kratos-rebirth\\source\\js下新建文件love.js,输入以下内容: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到小红心效果了","text":"博客美化1.添加鼠标点击爱心效果在\\themes\\kratos-rebirth\\source\\js下新建文件love.js,输入以下内容: 1!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到小红心效果了 2.添加鼠标点击烟花爆竹效果在\\themes\\kratos-rebirth\\source\\js下新建文件fireworks.js,输入以下内容: 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 在\\themes\\kratos-rebirth\\layout\\layout.ejs文章末尾加入: 1234&lt;!-- 页面点击烟花爆竹效果 --&gt;&lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt; 完成!鼠标点击就可以看到烟花爆竹了 3.浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \\themes\\kratos-rebirth\\source\\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617// 浏览器搞笑标题var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/favicon.ico&quot;); document.title = &#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;; clearTimeout(titleTime); &#125; else &#123; $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/favicon.ico&quot;); document.title = &#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#x27; + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 12&lt;!--浏览器搞笑标题--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/FunnyTitle.js&quot;&gt;&lt;/script&gt; 4.背景添加动态线条效果在 \\themes\\kratos-rebirth\\layout\\layout.ejs 文件中添加如下代码： 1234&lt;!--动态线条背景--&gt;&lt;script type=&quot;text/javascript&quot;color=&quot;220,220,220&quot; opacity=&#x27;0.7&#x27; zIndex=&quot;-2&quot; count=&quot;200&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）opacity：表示线条透明度（0~1），默认：0.5count：表示线条的总数量，默认：150zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 5.小宠物挂件(小仓鼠)1&lt;iframe width=&quot;100%&quot; height=&quot;300&quot; frameborder=&quot;0&quot; src=&quot;https://cdn.abowman.com/widgets/hamster/hamster.html?up_bgColor=425066&amp;up_bodyColor=C0C0C0&amp;up_earColor=C0C0C0&amp;up_snoutColor=FFFFFF&amp;up_eyeColor=392f41&amp;up_feetColor=FFFFFF&amp;up_tailColor=C0C0C0&amp;up_waterColor=87CEFA&amp;up_foodColor=cba920&amp;up_wheelColor=ffffff&amp;up_wheelOuterColor=ff4d4d&amp;up_wheelCenterColor=ffffff&amp;up_wheelSpokeColor=dedede&quot;&gt;&lt;/iframe&gt; 6.天气预报1&lt;iframe allowtransparency=&quot;true&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;200&quot; scrolling=&quot;no&quot; src=&quot;//tianqi.2345.com/plugin/widget/index.htm?s=2&amp;z=1&amp;t=1&amp;v=0&amp;d=5&amp;bd=1&amp;k=000000&amp;f=&amp;ltf=009944&amp;htf=cc0000&amp;q=1&amp;e=1&amp;a=1&amp;c=54511&amp;w=100%&amp;h=200&amp;align=center&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客美化","slug":"博客美化","permalink":"https://drfengling.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"}]},{"title":"搭建个人博客(六)","slug":"搭建个人博客-六","date":"2022-04-16T01:40:04.000Z","updated":"2022-04-19T06:39:00.329Z","comments":true,"path":"qm/31df0a78.html","link":"","permalink":"https://drfengling.github.io/qm/31df0a78.html","excerpt":"Aplayer音乐播放器1&#123;% meting &quot;19723756&quot; &quot;netease&quot; &quot;playlist&quot; %&#125;","text":"Aplayer音乐播放器1&#123;% meting &quot;19723756&quot; &quot;netease&quot; &quot;playlist&quot; %&#125; 如果没有显示歌单,请刷新一下.","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Aplayer","slug":"Aplayer","permalink":"https://drfengling.github.io/tags/Aplayer/"}]},{"title":"搭建个人博客(五)","slug":"搭建个人博客-五","date":"2022-04-15T07:46:26.000Z","updated":"2022-04-19T06:39:31.441Z","comments":true,"path":"qm/a8d0420a.html","link":"","permalink":"https://drfengling.github.io/qm/a8d0420a.html","excerpt":"插入视频插入B站视频1234&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;","text":"插入视频插入B站视频1234&lt;div style=&quot;position: relative; width: 100%; height: 0; padding-bottom: 75%;&quot;&gt;&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=39807850&amp;cid=69927212&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot;&gt; &lt;/iframe&gt;&lt;/div&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://drfengling.github.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"搭建个人博客(四)","slug":"搭建个人博客-四","date":"2022-04-15T07:39:32.000Z","updated":"2022-04-19T06:39:23.184Z","comments":true,"path":"qm/ae7b1577.html","link":"","permalink":"https://drfengling.github.io/qm/ae7b1577.html","excerpt":"插入音乐需要使用 iframe 标签 在实际运用中，可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=86 src=&quot;//music.163.com/outchain/player?type=3&amp;id=2501767770&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","text":"插入音乐需要使用 iframe 标签 在实际运用中，可以使用网易云音乐，搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器。 1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=100% height=86 src=&quot;//music.163.com/outchain/player?type=3&amp;id=2501767770&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://drfengling.github.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"搭建个人博客(三)","slug":"搭建个人博客-三","date":"2022-04-15T06:41:37.000Z","updated":"2022-04-19T06:39:11.589Z","comments":true,"path":"qm/5438fa78.html","link":"","permalink":"https://drfengling.github.io/qm/5438fa78.html","excerpt":"创建歌单页面由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。","text":"创建歌单页面由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为playlist： 1hexo new page playlist 这时候在 /Hexo/source 文件夹下会生成一个playlist文件夹，打开里面的index.md，修改如下： 123title: 歌单date: 2019-02-21 16:14:00type: &quot;playlist&quot; 打开主题的 _config.yml文件，在menu下新建一个名为playlist的类（注意这里使用的图标是图标库中的图标，网址为 http://www.fontawesome.com.cn/faicons/ 。可以选择自己喜欢的图标，我这里选择的是music）。完成后如下所示： 1234567menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive playlist: /playlist/ || music about: /about/ || user 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: playlist: 歌单 这样歌单就创建完成啦~ 使用 hexo-tag-aplayer 插件hexo-tag-aplayer 是Aplayer在hexo上的插件，这里的配置参考的是官方文档 ，第一步安装 hexo-tag-aplayer： 1npm install --save hexo-tag-aplayer 最新版的 hexo-tag-aplayer 已经支持了MetingJS的使用，可以直接解析网络平台的歌曲（简直是神器），首先要在站点配置文件中开启meting模式，添加以下代码在配置文件的最后： 12aplayer: meting: true 复制歌单的链接，然后复制歌单的id，例如 https://music.163.com/playlist?id=19723756 ，这个歌单的id就是19723756，公司名可以是tencent、netease或是其他公司，下面给出一个例子，打开 /Hexo/source/playlist/index.md文件，输入： 1&#123;% meting &quot;523845661&quot; &quot;netease&quot; &quot;playlist&quot; &quot;theme:#FF4081&quot; &quot;mode:circulation&quot; &quot;mutex:true&quot; &quot;listmaxheight:340px&quot; &quot;preload:auto&quot; %&#125; 效果还是很不错的：","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"音乐","slug":"音乐","permalink":"https://drfengling.github.io/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"搭建个人博客(二)","slug":"发布第二篇个人博客","date":"2022-04-15T01:18:10.000Z","updated":"2022-04-19T06:39:43.487Z","comments":true,"path":"qm/4b6f21d9.html","link":"","permalink":"https://drfengling.github.io/qm/4b6f21d9.html","excerpt":"新建文章与页面12hexo new &quot;title&quot; # 生成新文章: \\source\\_posts\\title.mdhexo new page &quot;title&quot; # 生成新的页面, 后面可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面, 文章对应的是 post.md , 页面对应的是page.md, 草稿的是draft.md","text":"新建文章与页面12hexo new &quot;title&quot; # 生成新文章: \\source\\_posts\\title.mdhexo new page &quot;title&quot; # 生成新的页面, 后面可在主题配置文件中配置页面 生成文章或页面的模板放在博客文件夹根目录下的 scaffolds/ 文件夹里面, 文章对应的是 post.md , 页面对应的是page.md, 草稿的是draft.md 编辑文章打开新建的文章\\source_posts\\postName.md, 其中postName是hexo new “title”中的title 12345678910111213141516---title: 搭建个人博客(二) # 文章页面上的显示名称, 可以任意修改, 不会出现在URL中categories: # 文章分类目录, 多个分类使用[a,b,c]这种格式 - 博客日记tags: # 文章标签 - Hexo - GitHub - Nodejsabbrlink: 4b6f21d9 #短链接date: 2022-04-15 09:18:10 # 文章生成时间, 一般不改---#这里开始使用markdown格式输入你的正文. &lt;!--more--&gt; #more标签以下的内容要点击“继续阅读”才能看见 插入图片插入图片有三种方式方式一在博客根目录的 source 文件夹下新建一个 img 文件夹专门存放图片, 在博文中引用的图片路径为 /img/图片名.后缀 1![](图片路径) 方式二图片插件在hexo中使用文章资源文件夹需要在config.yaml文件中更改一下配置： 1post_asset_folder: true 当该配置被应用后，使用hexo new命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。 插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 图片放入文章资源夹 之后就可以在使用 1![](image.jpg) 的方式愉快的插入图片了。 方式三1![](使用网络图片:http://www.dmoe.cc/random.php) 简单的命令总结一下简单的使用命令1234567hexo init [folder] # 初始化一个网站. 如果没有设置 folder , Hexo 默认在目前的文件夹建立网站hexo new [layout] &lt;title&gt; # 新建一篇文章. 如果没有设置 layout 的话, 默认使用 _config.yml 中的 default_layout 参数代替. 如果标题包含空格的话, 请使用引号括起来hexo version # 查看版本hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g # 等于hexo generate # 生成静态文件hexo s # 等于hexo server # 本地预览hexo d # 等于hexo deploy # 部署, 可与hexo g合并为 hexo d -g","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengling.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengling.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengling.github.io/tags/Nodejs/"}]},{"title":"搭建个人博客(一)","slug":"发布第一篇个人博客","date":"2022-04-13T00:48:09.000Z","updated":"2022-04-19T06:39:53.617Z","comments":true,"path":"qm/387162d6.html","link":"","permalink":"https://drfengling.github.io/qm/387162d6.html","excerpt":"一.初识Hexo;快速、简洁且高效的博客框架，官网：https://hexo.io/zh-cn/是这么介绍的，嗯，有道理，那么我就不赘述了，想要更透彻了解的可自行查阅。 但是要知道它是个博客框架，有很多好看的主题https://hexo.io/themes/可以应用在自己的博客上，这篇文章要讲述如何用hexo写博客并部署到github上就好了。","text":"一.初识Hexo;快速、简洁且高效的博客框架，官网：https://hexo.io/zh-cn/是这么介绍的，嗯，有道理，那么我就不赘述了，想要更透彻了解的可自行查阅。 但是要知道它是个博客框架，有很多好看的主题https://hexo.io/themes/可以应用在自己的博客上，这篇文章要讲述如何用hexo写博客并部署到github上就好了。 二.安装前提;安装 Hexo 相当简单，只需要先安装下列应用程序即可： Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)Git如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 安装 Hexo 步骤。 三.安装Hexo;所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 进阶安装和使用对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。 1$ npm install hexo 四.搭建博客;安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 这里我在J:\\WEIXIN\\Blog下新建了文件夹博客日记作为演示1.打开cmd命令行或Windows Power Shell 123456Windows PowerShell版权所有 (C) Microsoft Corporation。保留所有权利。尝试新的跨平台 PowerShell https://aka.ms/pscore6PS C:\\Users\\Administrator&gt; J: 2.切换到J盘文件夹目录 1PS J:\\&gt; cd J:\\WEIXIN\\Blog\\博客日记 3.初始化hexo博客文件 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git\u001b[32mINFO \u001b[39m Install dependenciesINFO Start blogging with Hexo! 新建完成后，指定文件夹的目录如下： 123456789.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes_config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 1234567891011121314151617181920package.json&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.8.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot; &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。4.启动Hexo $ hexo s 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo sINFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop. 5.浏览器输入：http://localhost:4000，可查看到默认生成了一篇博文： 6.新建一篇博文ctrl+c断开刚刚的链接，新建一篇博文：hexo n “发布第二篇个人博客” 1234PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo n &quot;发布第二篇个人博客&quot;INFO Validating configINFO Created: J:\\WEIXIN\\Blog\\博客1\\source\\_posts\\发布第二篇个人博客.mdPS J:\\WEIXIN\\Blog\\博客日记&gt; 5、接下来就是更改博文内容，可以选择用命令行，也可用开发工具，我直接使用记事本打开该文件了，找到相应的位置，做修改即可6、同样在博客日记文件下： 清理：hexo clean 生成：hexo g 启动：hexo s 12345PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo cl..PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo g..PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo s 完成! 五.部署到Github上;1、登录github：https://github.com，没账号的新建一个，新创建一个仓库New repository，仓库名必须为：昵称.github.io:，输入描述，创建：2、命令行下，ctrl+c，退出命令，仍然在博客日记目录下，安装git部署插件：npm install hexo-deployer-git –save 1PS J:\\WEIXIN\\Blog\\博客日记&gt; npm install hexo-deployer-git --save 3、更改博客日记文件夹下，_config.yml的配置，我直接用记事本了，用命令行修改也可以： repo为第一步创建的git仓库 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/Drfengling/Drfengling.github.io.git branch: main 4.回到命令行部署到远端 1PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo d 中间会让输入github密码，输入即可，后续部署完成，即可访问你的远端地址：https://Drfengling.github.io###五.Hexo主题的使用；1、选主题：https://hexo.io/themes/，有很多主题可供选择，也可使用网友推荐的自己喜欢的主题，有相应的预览、github地址： 我这里使用的是： diaspora： https://github.com/Fechin/hexo-theme-diaspora 有相应的安装方法： 1PS J:\\WEIXIN\\Blog\\博客日记&gt; git clone https://github.com/Fechin/hexo-theme-diaspora.git themes/diaspora 修改Hexo配置文件 _config.yml 主题项设置为diaspora 123...theme: diaspora... 3、清理、启动： 清理：hexo clean 生成：hexo g 启动：hexo s 123PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo clPS J:\\WEIXIN\\Blog\\博客日记&gt; hexo gPS J:\\WEIXIN\\Blog\\博客日记&gt; hexo s 在本地刷新预览http://localhost:4000之后，看到主题效果，可根据自己需要做相应修改即可。 4、推至远端： ctrl+c退出上一步命令，然后推至远端： 1PS J:\\WEIXIN\\Blog\\博客日记&gt; hexo d 刷新查看：https://Drfengling.github.io以上就是搭建个人博客的全过程了，也可以购买自己的域名，放置自己的域名下","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengling.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengling.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengling.github.io/tags/Nodejs/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-12T03:04:16.405Z","updated":"2022-04-14T09:07:21.479Z","comments":true,"path":"qm/4a17b156.html","link":"","permalink":"https://drfengling.github.io/qm/4a17b156.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://drfengling.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengling.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengling.github.io/tags/Nodejs/"}]},{"title":"为什么要写博客?","slug":"为什么要写博客","date":"2022-04-12T02:40:14.000Z","updated":"2022-04-19T06:40:02.609Z","comments":true,"path":"qm/d2b740ea.html","link":"","permalink":"https://drfengling.github.io/qm/d2b740ea.html","excerpt":"一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。","text":"一个选择我知道现在可能说这话有点不合时宜，毕竟博客时代都已经过去了，再号召大家用过就好像时的东西是不是有点逆流而上？ 我曾经也问过自己这个问题，但是我觉得，博客时代过去跟我们要开博客是没有多大关系的，就好像你的读书时代已经过去你就不再读书一样。 判断一件事情值不值得去做有一个方法：在一张白纸的左边写不值得做的原因，然后在右边写值得做的原因，写完一比较，一权衡，自然能够得出结果。 大家都成年人了，你会觉得这样思考分析总结的过程才是正确的思考的方法吧？ 所以，我在这里列出要写（独立）博客的原因，供大家去选择，然后填在你白纸的右边。 注意，我不是给你一个建议，而是提供一个选择，这个选择蕴藏着我也不知道的可能。 博客的内容写博客不难，你可以当作是生活的记录，但是这样的记录没有任何的意义。写要对得住写本身，写出来的东西应该是思考的结果。我认为，如果你要开一个博客，博客的内容应该是这样的： 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……； 有目的地写，要务实，追求质量； 承认真实的自己，不要吹嘘，不要装逼，无需讨好读者； 记录自己学习、思考、总结的过程； 分享你的故事、所得、感想、经验；值得写的原因以下是一个清单，可以根据自己的情况匹配，然后选择。 重新认识自己是不是很久没有跟自己对话了？ 你可以尝试从回答一些问题开始，将你过去要回避的问题写下来，例如就可以从这个九个问题开始： 1、请你介绍一下你自己，你是个什么样的人？ 2、你有什么理想吗？这个理想是怎么形成的？ 3、你理想的伴侣关系是什么样的？你自己在这个伴侣关系中扮演什么样的角色？要承担什么样的责任？ 4、你理想的事业是什么，你正在做的工作符合你的事业理想吗？这份工作对你的意义是什么？ 5、你对亲子关系怎么看？对你来说，什么是一个理想的父亲（母亲），你期望自己成为这样一个理想父亲（母亲）吗？ 6、你对钱怎么看，你认为赚到多少钱是足够的？如果你明天一早醒来，已经有足够的钱，你将会如何继续安排自己的生活？ 7、你的择友标准是什么？什么样的人你会愿意交往，什么样的人你会拒绝和他交往？ 8、你对死亡怎么看？你希望自己活到多少岁，你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱，这份遗嘱会怎么写？ 以上的这八个问题摘自《很少人能顺畅回答这8个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮。 这些问题的答案你可以选择不发，但是我强烈地建议写下来，只有在写的时候你才可以慎重地思考这些问题，而不会回避跳过或者留下空白，这是接受自己的第一步。 提供持续学习的动力例如，我为自己设限每天写一千字，信息的不断输出给我带来恐惧，我害怕有一天我写无可写，于是我不停地阅读，通过个人的知识管理促使自己不断学习，提高核心竞争力。 积累更多的知识写并不是单纯的写。 例如你写着写着，你突然忘记了一个概念，于是上网找，找回来这个概念的时候，你重温这个概念，可能还会顺便看了一下这个概念的其他东西。 例如你需要获取第一手的资料，寻找信息来源本身就是一个知识积累的过程，同时，你慢慢就学会了鉴别知识：什么是没有用的心灵鸡汤，什么是不值得关注的吐槽名人，还有，在这个过程中，你还养成你的心智。 提高将事情讲清楚的能力很多东西你以为懂了，但当你在写下来的时候，你就觉得无从下手了。 如果一件事情你不能讲清楚，十有八九你还没有完全理解。 将事情写下来，慢慢就可以提高你的逻辑思维能力，分析能力，写会迫使你在你脑中搭建一个有条理的框架。例如我写这篇文章一样，我就将值得写博客的原因一点一点地罗列出来，事情就更加清晰，你也可以更好的思考问题。 分享带来的连锁反应“通过分享，你获得了直接而快速的回报，你最终或许会发现你已将版权和“保留所有权利”抛诸脑后。新的经济学准则是：参与你作品的人越多，回报越高。在分享主义里，如果你愿意你可以保留所有权，但是我乐于分享。” by 毛向辉 《分享主义：一场思维革命》 互联网精神其中最重要的就是分享主义，基于分享主义，你可以享受到社会化及互联网给你带来的种种便利和好处，你分享了一个知识，你就成为了互联网中的一个点，这个点的大小由你自己来决定，互联网的大潮会将你的这个点推送到它所能触及的每个角落，让需要的人得到，同时，你的这个点也会继续扩大，连接到整个网络，这个点有可能连接成一张网，而你就是这张网的中心。 帮你找到志同道合的人在微博，在朋友圈，你可能找不到跟你志同道合的人，而在博客，你可以通过看他的几篇文章就迅速地理解认同这个人，即使你没有见过这个人，但你也可以通过这种关联来相互学习。 如果你在一个领域有相当的了解，你将这些内容发在网络上，网络上跟你志趣相投的人也会被你吸引过来，根据吸引力法则，你是怎样的人你就被怎么样的人吸引，这就是博客所能赋予你的魅力。 即使博客没有被他人关注，我们依然可以找到同好，你可以自己将博文转载到其他站点，人们会通过搜索引擎找到你，有邮件、微博等工具，我们不乏与他人交流的途径。by Gabriel Weinberg《Why I blog》 记录成长隔一段时间，你再回头看你写的博客，你会发现自己正在通过这样的方式在不断的成长，这种成长在自己眼里是一种财富，在别人眼里是一张地图，你得到了收获，不断修正自己的错误，别人得到了指引，避免走弯路。 更多的情况是当你回望自己的时候你会发现自己是一个傻逼，so what，that is what I am！ 培养持续做一件事情的能力开始是坚持，后来是习惯，接着喜欢。以后当有人对你说，「你写那么多有用的东西，你真的很厉害啊！」你可以笑而不语，也可以大声说道：「你妹，你不知道我开始的时候多么痛苦！」 让你长久地去跑步，你可能做不到；让你每个月看一本书，你也可能做不到；但让你持续地写一个博客，你可以做得到。 你不相信？你不试试你怎么知道？ 默默地持续做一件事是一种难得的能力，也是一种难得的品质。 讨论反思每人都会有思维的盲点，就好像这篇文章一样，可能你觉得我可能说得不对，你可以反驳我，我欢迎这种讨论，因为讨论的过程中会产生各种的思维的碰撞，这种碰撞会让你反思，也会激发出你新的灵感，这种讨论反思给自己的带来巨大的受益。 互联网给你的反馈就是让你承受更多，接受更多，成为一个更好的人。 ###搜寻到你意想不到东西世界不止是你的家，你的公司，你的朋友圈，你应该去发现一个更大的世界，通过写博客，你会知道世界上还有很多人像你一样在写博客，这些人和知识正在世界的某个角落在等着你。 例如，在写这篇文章的过程中，我才知道了Gabriel Weinberg，我才要将阳志平的博客重读一遍。写的过程会让你有很多新的发现，这些新的发现都值得你去再写下来，总结分享出去。 一个人在做一件属于自己的事很多你认为自己很牛逼的事情都是自己一个人做出来。 别人在刷微博，你在看书，别人在看穿越剧，你在学英文，别人在去唱K，你在写个人总结。吃饭也要找同伴，出游要找同伴，看电影要找同伴，你上一次一个人在做一件属于自己的事是在什么时候？ 如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，收到的阻力也会越大。因为你没有迎合社会习俗，而是一步步地与它背道而驰。如果自己就是潮水的一部分 ，怎么能看见潮流的方向呢？你只能永远保持质疑，问自己，什么话是我不能说的？为什么？——Paul Graham《不能说的话》 互联网的身份识别：一个长期的价值博客是一份很好的简历。这里的“简历”并非是狭义上的求职简历，毕竟现在还没有到价值博客的时代，很多人写博客都是到处转载或者干脆碎碎念，正因此面试官未必拿个人博客当成了解一个人的更可靠窗口。 这里的“简历”是指一个让别人了解自己的窗口，虽然我们未必做得到像罗永浩、Keso这样的博客，个人的影响力已经足以支撑出一份事业（牛博和5gme），但至少你会因此而结识更多的人，你的博客价值越高，你结识的人就越牛，跟牛人交流又会让你的眼界得到极大的开阔，打开一扇又一扇你原本不知道的门，于是你就变得更牛… 这是一个良性循环。by 刘未鹏 最后你可能想不到在白纸的左边（不值得写博客的原因）写什么了，想不到写个「博客时代已经过去」或者「我没有时间」也可以，但与此同时，你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」。","categories":[{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://drfengling.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}],"categories":[{"name":"Web服务","slug":"Web服务","permalink":"https://drfengling.github.io/categories/Web%E6%9C%8D%E5%8A%A1/"},{"name":"C#","slug":"C","permalink":"https://drfengling.github.io/categories/C/"},{"name":"线上评论","slug":"线上评论","permalink":"https://drfengling.github.io/categories/%E7%BA%BF%E4%B8%8A%E8%AF%84%E8%AE%BA/"},{"name":"博客日记","slug":"博客日记","permalink":"https://drfengling.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://drfengling.github.io/tags/Nginx/"},{"name":"WCF","slug":"WCF","permalink":"https://drfengling.github.io/tags/WCF/"},{"name":"Gitalk","slug":"Gitalk","permalink":"https://drfengling.github.io/tags/Gitalk/"},{"name":"livere","slug":"livere","permalink":"https://drfengling.github.io/tags/livere/"},{"name":"博客美化","slug":"博客美化","permalink":"https://drfengling.github.io/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"},{"name":"Aplayer","slug":"Aplayer","permalink":"https://drfengling.github.io/tags/Aplayer/"},{"name":"视频","slug":"视频","permalink":"https://drfengling.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"音乐","slug":"音乐","permalink":"https://drfengling.github.io/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Hexo","slug":"Hexo","permalink":"https://drfengling.github.io/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"https://drfengling.github.io/tags/GitHub/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://drfengling.github.io/tags/Nodejs/"},{"name":"日记","slug":"日记","permalink":"https://drfengling.github.io/tags/%E6%97%A5%E8%AE%B0/"}]}